1.定义decode方法并传入加密参数a(string类型)
2.定义一个变量b
3.获取a的第一个字符并赋值给b
4.定义变量c,并且赋值为-1,定义常量数组arr=["=", ".", "-", "*"]
5.如果b等于常量数组arr的第二条数据 则变量c等于2 否则 如果b等于常量数组arr的第三条数据 则变量c等于1 否则 如果b等于常量数组arr的第四条数据 则变量c=0
6.把c的值赋给b
7.定义变量c2等于参数a从1号位开始的值(即去除a的第一位)
8.for循环
function decode(a){
  var b;
  b=a.charAt(0);
  var arr = ["=", ".", "-", "*"]
  var c=-1;
  b==arr[1]?c=2:b==arr[2]?c=1:b==arr[3]&&(c=0);
  b=c;
  for(var c2=a.substr(1), d=0, e=c2.length, f=[], a=[], g=[]; d<e; ){
    if(c2.charAt(d)==arr[0]){ //如果c2在d位置这里的元素等于arr的第一位
      if(13>e-d)return 0; 
      a:{  //函数体
        for(var g=c2.substr(d,13),i=f,k=0,l=0,m=0,n=0;6>n;n++){ //定义g等于c2从d位置到13位置的值
          m=ch(g.substr(1+n,1)); //ch为另一个方法,返回的是g在某个位置的值的计算结果
          if(0>m){
            g=-1-n;
            break a //跳出函数体
          }
          k+=m<<6*n; // << 是左移运算符(二进制) 例如 5 << 1 => 0101 << 1 结果为 1010 换成十进制为10
          m=ch(g.substr(7+n,1)); //跟上述ch方法用法一样
          if(0>m){
            g=-7-n;
            break a
          }
          l+=m<<6*n
        }
        i.push(k); //往i数组里塞入元素k
        i.push(l); //同理
        g=0
      }
      if(0>g)return 0;
      d+=13
    }else if(";"==c2.charAt(d)){
      a.push(f.slice(0)) //数组a中塞入f从位置0开始之后的元素
      f.length=0
      ++d; //d+1
    }else{
      if(8>e-d) 
        return 0;
        g=dh(c.substr(d, 8),f); //调用dh方法获取从d位置开始的后8位值
        if(0>g)return 0;
        d+=8
    }
  }
  c=0;
  for(d=a.length;c<d;c++){
    e=0;
    for(f=a[c].length;e<f;e++){
      a[c][e]/=100
    }
  }
  return a
}

//定义一个方法dh
function dh(a,b){
  var c=b.length; //定义变量c等于b的长度
  if(2>c)return-1; //如果2大于c则返回-1
  for(var d=0,e=0,f=0,g=0;4>g;g++){ //
    f=ch(a.substr(g,1)); 
    if(0>f)return-1-g;
    d+=f<<6*g;
    f=ch(a.substr(4+g,1));
    if(0>f)return-5-g;
    e+=f<<6*g
  }
  d>8388608&&(d=8388608-d); //如果d>8388608则d=8388608-d
  e>8388608&&(e=8388608-e);
  b.push(b[c-2]+d); //把参数b在位置c-2的值加上d的值再次塞到参数b中
  b.push(b[c-1]+e);
  return 0
}

//定义一个方法ch
function ch(a){
  var b=a.charCodeAt(0); //定义变量b=参数a在0位置的Unicode编码
  return "A"<=a&&"Z">=a ? b-65 : "a"<=a&&"z">=a ? 26+b-97 : "0"<=a&&"9">=a ? 52+b-48 : "+"==a ? 62 : "/"==a ? 63 : -1 //多个二元一次判断
}; 

//另一套算法 拿到上述decode的值后, 传入进来, lng是a[0] lat是a[1]
function convert(a){
  var b, c;
  var tG = [1.289059486E7, 8362377.87, 5591021, 3481989.83, 1678043.12, 0]
  var sP = [[1.410526172116255E-8, 8.98305509648872E-6, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 1.73379812E7], [-7.435856389565537E-9, 8.983055097726239E-6, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486E7], [-3.030883460898826E-8, 8.98305509983578E-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552E-8, 8.983055099779535E-6, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437E-9, 8.983055096812155E-6, 6.995724062E-5, 23.10934304144901, -2.3663490511E-4, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878E-9, 8.983055095805407E-6, -3.068298E-8, 7.47137025468032, -3.53937994E-6, -0.02145144861037, -1.234426596E-5, 1.0322952773E-4, -3.23890364E-6, 826088.5]] //二维数组
  b = H(Math.abs(a[0][0]), Math.abs(a[0][1])); //初始化b并且将里面的string有可能的转化为float,最后得到的是一个哈希对象
  for (var d = 0; d < tG.length; d++){ //循环tG的长度
    if (b.lat >= tG[d]) { //如果b的lat 大于 tG数组中d位置的值 则把sP数组里d位置的数组赋值给c并跳出循环
      c = sP[d]; 
      break
    }
  }
  a = qK(a, c); //把参数a跟c传入qK方法进行重新计算
  return a = new H(a.lng.toFixed(6), a.lat.toFixed(6))
}

function H(a, b){
  is_string(a) && (a = parseFloat(a)); //如果是string转为float(浮点数)类型
  is_string(b) && (b = parseFloat(b));
  return {lng: a, lat: b}
}

//此方法只是判断是不是string类型
function is_string(a){
  return "string" == typeof a
}

function qK(a, b) {
  if (a && b) { //如果a b参数均存在
    var c = b[0] + b[1] * Math.abs(a[0][0]) //定义变量c等于参数b里的第一位加上第二位乘以参数a.lng的绝对值
      , d = Math.abs(a[0][1]) / b[9]  //定义变量d等于参数a.lat的绝对值除以参数b的第10位
      , d = b[2] + b[3] * d + b[4] * d * d + b[5] * d * d * d + b[6] * d * d * d * d + b[7] * d * d * d * d * d + b[8] * d * d * d * d * d * d //让变量d等于此算法的结果值
      , c = c * (0 > a[0][0] ? -1 : 1)
      , d = d * (0 > a[0][1] ? -1 : 1);
    return H(c,d) //返回新的值
  }
}